#!/usr/bin/env bash
set -euf
set -o pipefail
trap "exit 1" TERM
function helpme {
	if [ $# -gt 0 ]
	then
		echo -e "$1" 1>&2
	else
		grep '#' /proc/$$/fd/255 | sed -n '/^#HELPME_START/,/^#HELPME_END/p' | grep -v "^#HELPME_" | sed -e "s/#//" | tr -s '\t' 1>&2 #20220313
	fi
	PGID=$(cut -d ' ' -f 5 /proc/$$/stat)
	kill -s TERM -- -$PGID
}
function get_free_ports {
	[ "$1" != "tcp" -a "$1" != "udp" ] && helpme "ERR-015: contact developer"
	export LC_ALL=C
	join -v 1 <(seq $2 $3) <(netstat --inet -ln${1:0:1} | grep ^$1 | awk '{print $4}' | cut -d : -f 2 |sort) | shuf | head -n $4
}
function get_hostfwd {
	PROTO=$1
	shift
	[ -z "$1" ] && return
	COUNT=$(echo "$@" | sed -e "s/ /\n/g" | wc -l)
	paste <(get_free_ports $PROTO 40000 50000 $COUNT) <(echo "$@" | sed -e "s/ /\n/g") | awk -v PROTO=$PROTO '{if (NR>1) printf ","; printf "hostfwd=%s::%s-:%s", PROTO, $1, $2}'
}
function usage {
	helpme "Usage: daiker <command> [-h] [<args>]
commands:
	build
	run	
	convert"
}
function is_not_base_image {
	qemu-img info $1 | grep -q "backing file:"
}
[ $# -gt 0 ] || usage
[ "$1" != "-h" -a "$1" != "--help" -a "$1" != "help" ] || usage
COMMAND=$1
OPT_SHORT="hvc:r:i:de:M:T:U:D:Q:"
OPT_LONG="help,version,cpu:,ram:,iso:,disable-public-net,enable-private-net:,mount:,tcp-ports:,udp-ports:display:,qemu-parameters"
shift || usage
if [ "$COMMAND" = "build" ]
then
	OPT_SHORT="${OPT_SHORT}H:"
	OPTS=$(getopt -o $OPT_SHORT --long "$OPT_LONG,hda-size:" -n daiker -- "$@")
elif [ "$COMMAND" = "run" ]
then
	OPT_SHORT="${OPT_SHORT}b:B:"
	OPTS=$(getopt -o $OPT_SHORT --long "$OPT_LONG,base:,force-base:" -n daiker -- "$@")
elif [ "$COMMAND" = "convert" ]
then
	OPT_SHORT="hv"
	OPT_LONG="help,version"
	OPTS=$(getopt -o $OPT_SHORT --long $OPT_LONG -n daiker -- "$@")
else
	helpme "ERR-001: unsupported daiker command"
fi
CPU=2
BASE=""
ISO=""
CDROM=""
RAM=4
HDS=50
VNC=no
ENABLEPRIVATENET=""
DISABLEPUBLICNET=""
FORCE=""
MOUNTDIRS=()
TCPPORTS=()
UDPPORTS=()
PRVNET=""
PUBNET="-device e1000,netdev=n0 -netdev user,id=n0"
QEMU_DISPLAY=gtk
QEMU_PARAMETERS=""
eval set -- "$OPTS"
while :
do
	case "$1" in
#HELPME_START
#NAME
#build	daiker build - build a base image
#run	daiker run - run an overlay image
#convert	daiker convert - convert an overlay image to a base image
#SYNOPSIS
#build	daiker build [OPTION]... FILE|/dev/null
#run	daiker run [OPTION]... FILE
#convert	daiker convert FILE
#EXAMPLE
#build	daiker build -H 50 -i ubuntu-18.04.5-live-server-amd64.iso BionicBeaverBase.qcow2
#run	daiker run -b BionicBeaverBase.qcow2 BionicBeaverTest.qcow2
#run	daiker run -T 22 -T 80 BionicBeaverTest.qcow2
#convert	daiker convert BionicBeaverTest.qcow2
#OPTIONS
		-h | --help)	#print help information
			helpme ;;
		--version)	#print version
			helpme 20220410
			shift ;;
		-v )	#verbose output
			set -x
			shift ;;
		-c | --cpu)	#=CPU, number of cpus, default 2
			[ "$2" -eq "$2" ] 2> /dev/null || helpme "ERR-021: invalid number: -c $2"
			CPU=$2
			shift 2 ;;
		-r | --ram)	#=RAM, memory size, in GB, default 4
			[ "$2" -eq "$2" ] 2> /dev/null || helpme "ERR-022: invalid number: -r $2"
			RAM=$2
			shift 2 ;;
		-i | --iso)	#=ISO file, used as cdrom
			ISO=$2
			shift 2 ;;
		-d | --disable-public-net)	#disable public net. The machine won't be able to access the Internet
			DISABLEPUBLICNET=YES
			shift 1 ;;
		-e | --enable-private-net)	#=random/11:22:33, add a NIC with a specfic or random mac address to share the same private network traffic with other virtual machines that also used '-e'. If it is not "random", the mac address will be prepended with '52:54:00'
			ENABLEPRIVATENET=$2
			shift 2 ;;
		-M | --mount)	#=DIR, allows virtual machine to mount multiple directories on the physical host with some command like 'mount -t 9p -o msize=1048576 daiker-0 /mnt', where 'daiker-0' means the first -m option. Default CentOS or Windows doesn't support this feature
			MOUNTDIRS+=($2)
			shift 2 ;;
		-T | --tcp-ports)	#=VMPORT or VMPORT-HOSTPORT, tcp port HOSTPORT on the host is forwarded to VMPORT on the virtual machine
			if [[ "$2" == *"-"* ]]
			then
				IFS=- read VPORT HPORT <<< "$2"
				[ "$HPORT" -eq "$HPORT" ] && [ "$VPORT" -eq "$VPORT" ] 2> /dev/null || helpme "ERR-023: invalid number: -T $2"
				PUBNET="$PUBNET,hostfwd=tcp::$HPORT-:$VPORT"
			else
				[ "$2" -eq "$2" ] 2> /dev/null || helpme "ERR-024: invalid number: -T $2"
				TCPPORTS+=($2)
			fi
			shift 2 ;;
		-U | --udp-ports)	#=VMPORT or VMPORT-HOSTPORT, udp port HOSTPORT on the host is forwarded to VMPORT on the virtual machine
			if [[ "$2" == *"-"* ]]
			then
				IFS=- read VPORT HPORT <<< "$2"
				[ "$HPORT" -eq "$HPORT" ] && [ "$VPORT" -eq "$VPORT" ] 2> /dev/null || helpme "ERR-026: invalid number: -U $2"
				PUBNET="$PUBNET,hostfwd=udp::$HPORT-:$VPORT"
			else
				[ "$2" -eq "$2" ] 2> /dev/null || helpme "ERR-027: invalid number: -U $2"
				UDPPORTS+=($2)
			fi
			shift 2 ;;
		-D | --display)	#gtk/vnc/none/nographic, default gtk, which requires X
			QEMU_DISPLAY=$2
			shift 2 ;;
		-Q | --qemu-parameters)	#Other qemu parameters. For example, to use a usb device, run "sudo chown $USER /dev/bus/usb/003/006; daiker run -Q "-device usb-ehci,id=ehci -device usb-host,hostbus=3,hostaddr=6" test.qcow2

			QEMU_PARAMETERS=$2
			shift 2 ;;
		-b | --base)	#=BASE, the base image that a new virtual machine will be created from. BASE should be the output file of 'daiker build'. Its actual format is a qemu image without backing file
			BASE=$2
			shift 2 ;;
		-B | --force-base)	#=FORCE-BASE, force the file FORCE-BASE to be the base image, even if FORCE-BASE is a qemu image requiring backing file. This option is not recommended as an accidental 'daiker run' on FORCE-BASE can cause disk corruption of any new virtual machines using FORCE-BASE as base
			FORCE=YES
			BASE=$2
			shift 2 ;;
		-H | --hda-size)	#=SIZE, hard drive size, in GB, default 50
			[ "$2" -eq "$2" ] 2> /dev/null || helpme "ERR-025: invalid number: -H $2"
			HDS=$2
			shift 2 ;;
		--)
			shift
			break ;;
		*)
			break ;;
#AUTHOR
#	Manhong Dai
#COPYRIGHT
#	Copyright Â© 2002-2022 University of Michigan, 2022 KLA.
#	License GPLv3+: GNU GPL version 3 or later
#	<https://gnu.org/licenses/gpl.html>.
#	This is free software: you are free to change and redistribute it.
#	There is NO WARRANTY, to the extent permitted by law.
#HELPME_END
	esac
done
[ $# -eq 1 ] || helpme "ERR-002: run 'daiker -h/--help' or 'daiker $COMMAND -h/--help'"
FILE=$1
[ ! -z "$FILE" ] || helpme "ERR-003: missing FILE"
HDA="-hda $FILE"
MOUNTS=""
for ((IDX=0; IDX<${#MOUNTDIRS[@]}; IDX++))
do
	[ -d ${MOUNTDIRS[$IDX]} ] || helpme "ERR-020: no such dir ${MOUNTDIRS[$IDX]}"
	MOUNTS="$MOUNTS -virtfs local,id=daiker-$IDX,path=${MOUNTDIRS[$IDX]},security_model=none,multidevs=remap,mount_tag=daiker-$IDX"
done
if [ -n "$ENABLEPRIVATENET" ]
then
	if [ "$ENABLEPRIVATENET" = "random" ]
	then
		MAC=$(printf "52:54:00:%02x:%02x:%02x\n" $(( $RANDOM % 256)) $(( $RANDOM % 256)) $(( $RANDOM % 256)) )
	else
		MAC=$(printf "52:54:00:$ENABLEPRIVATENET\n")
	fi
	PRVNET="-device e1000,netdev=n1,mac=$MAC -netdev socket,id=n1,mcast=230.$(($(id -u) % 239)).$(($(id -u) % 241)).$(($(id -u) % 251)):$(($(id -u) % 9973 + 30000))"
fi
if [[ ${#TCPPORTS[@]} -gt 0 ]]
then
	[ "$DISABLEPUBLICNET" != "YES" ] || helpme "ERR-006: -T cannot be used with -d"
	HOSTFWD=$( get_hostfwd tcp ${TCPPORTS[@]} )
	[ -n "$HOSTFWD" ] || helpme "ERR-016: faield to get a idle tcp port on physical machine"
	echo "TCP ports: $HOSTFWD"
	PUBNET="$PUBNET,$HOSTFWD"
fi
if [[ ${#UDPPORTS[@]} -gt 0 ]]
then
	[ "$DISABLEPUBLICNET" != "YES" ] || helpme "ERR-030: -U cannot be used with -d"
	HOSTFWD=$( get_hostfwd udp ${UDPPORTS[@]} )
	[ -n "$HOSTFWD" ] || helpme "ERR-017: faield to get a idle udp port on physical machine"
	echo "UDP ports: $HOSTFWD"
	PUBNET="$PUBNET,$HOSTFWD"
fi
if [ "$QEMU_DISPLAY" = "gtk" ]
then
	set +u
	[ "$COMMAND" = "convert" -o -n "$DISPLAY" ] || helpme "ERR-004: '-D gtk' needs X, or you might want to try '-D vnc'"
	set -u
	QEMU_DISPLAY="-display gtk -vga std"
elif [ "$QEMU_DISPLAY" = "vnc" ]
then
	VNC=$(get_free_ports tcp 5900 6000 1)
	[ -z "$VNC" ] && help "ERR-014: no available vnc port"
	echo "VNC ports: $VNC" 
	((VNC=VNC-5900)) || :
	QEMU_DISPLAY="-display vnc=:$VNC"
elif [ "$QEMU_DISPLAY" = "none" ]
then
	QEMU_DISPLAY="-display none"
elif [ "$QEMU_DISPLAY" = "nographic" ]
then
	QEMU_DISPLAY="-nographic"
else
	help "ERR-018: invalid argument $QEMU_DISPLAY for '-display'. Try '-h'"
fi
if [ "$DISABLEPUBLICNET" = "YES" ]
then
	PUBNET=""
fi
if [ "$COMMAND" = "convert" ]
then
	is_not_base_image $FILE || helpme "ERR-028: $FILE is already a base image"
	read -p "convert \"$FILE\" to base image? type \"$FILE\" to confirm: " ANS
	[ "$ANS" == "$FILE" ] || helpme "Quitting"
	qemu-img rebase -F qcow2 -f qcow2 -b "" $FILE
	exit
elif [ "$COMMAND" = "build" ]
then
	if [ "$FILE" = "/dev/null" ]
	then
		HDA=""
	else
		[ ! -f $FILE ] || helpme "ERR-005: $FILE exists"
		[ ! -z "$HDS" ] || helpme "ERR-007: missing -H"
		qemu-img create -qf qcow2 $FILE ${HDS}G
		[ -z "$ISO" ] || CDROM="-cdrom $ISO"
	fi
elif [ "$COMMAND" = "run" ]
then
	if [ -n "$ISO" ]
	then
		[ -f "$ISO" ] || helpme "ERR-008: no such iso file $ISO"
		CDROM="-cdrom $ISO"
	fi
	if [ -n "$BASE" ]
	then
		[ -f $BASE ] || helpme "ERR-009: no such file $BASE"
		[ "$FORCE" = "YES" ] || ! is_not_base_image $BASE || helpme "ERR-019: $BASE is not a base image, please run 'daiker convert $BASE' to convert it first"
		[ ! -f $FILE ] || helpme "ERR-010: $FILE exists, don't use '-b $BASE' in the command, or delete '$FILE' to create a new image."
		DIRFILE=$(dirname $FILE)
		[ -d $DIRFILE ] || helpme "ERR-029: no such directory $DIRFILE"
		qemu-img create -qf qcow2 -b $(realpath --relative-to=$DIRFILE $BASE) -F qcow2 $FILE
	else
		[ -f $FILE ] || helpme "ERR-011: no such file $FILE"
		! fuser $FILE || helpme "ERR-012: $FILE is in use by the process above"
		is_not_base_image $FILE || helpme "ERR-013: $FILE is a base image, please run 'daiker run -b $FILE NEWFILE.qcow2' to create a new overlay image"
	fi
else
	usage
fi
qemu-system-x86_64 -cpu host -enable-kvm -usb -device usb-tablet -smp $CPU -m ${RAM}G $HDA $CDROM $PUBNET $PRVNET $MOUNTS $QEMU_DISPLAY $QEMU_PARAMETERS
